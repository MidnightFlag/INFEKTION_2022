<HTML>   
     <HEAD>
<TITLE>December 2000/Removing Image Noise with Adaptive Filters</TITLE></HEAD>
<BODY BACKGROUND="" BGCOLOR="#FFFFFF" TEXT="#000000">
<H2><A HREF="../tocdec.htm"><IMG SRC="../../toc.gif" ALT="{back to toc}" WIDTH="54" HEIGHT="54"></A><FONT COLOR="#FF0000">   Graphics</FONT></H2>

<HR>

<H2 ALIGN="center"><FONT COLOR="#800000">Removing Image Noise with Adaptive Filters</FONT></H2>
<H3 ALIGN="center"><FONT COLOR="#800000">Dwayne Phillips</FONT></H3>

<BLOCKQUOTE>
<p>There is no such thing as a universal filter, but we can get close by building one that adapts to the local noise. Dwayne Phillips walks us through the math to make a filter look a little bit smart.</p>
</BLOCKQUOTE>

<HR>
<BLOCKQUOTE>

<H4><FONT COLOR="#000080">Introduction</FONT></H4>

<p>Most images contain some type of noise. This occurs today more than ever since people are using home scanners and digital cameras. These inexpensive input devices work only as well as their users (amateurs like me) handle them. We tend to over-expose images and allow dust to accumulate on lenses and scanner glass. How do you remove the noise from such images? How do those software packages that come with the cameras and scanners do it? This article discusses one method: adaptive filtering. Adaptive filters combine simple filter concepts with decision making logic to change or adapt their behavior based on the image and noise content.</p>

<H4><FONT COLOR="#000080">Simple Filters and Noise</FONT></H4>

<p>Two commonly used image filters are the mean and median filters. (An earlier paper in this series discussed median filtering of spatial frequencies. See <a href="#1">[1]</a>.) The mean filter calculates the mean or average pixel value in a region. The median filter finds the median pixel value in a region. (Line up the pixels, sort them by value, and select the one in the middle.) Each of these filters work well in specific situations. As I will show, they are not right for every noisy image.</p>
<p>The mean filter works well on noise where the pixel value (the color, or intensity for grayscale images) of the noise is similar to the image's pixel values. The averaging effect of the mean filter tends to smooth away this noise. The mean filter, however, tends to blur edges in an image. If the noise is in the form of impulses or spots, these impulses act like edges, and the mean filter smudges them.</p>
<p><a href="image1.htm">Image 1</a> is (left to right) an image of a boy, that image corrupted with noise, and the result of the mean filter applied to the noisy image. This noise contains bright and dark impulses. Notice how the mean filter only smudged or blurred the noise. It did not remove it.</p>
<p>The median filter works well on impulse or spot noise. It throws away those outlying pixels without averaging their values. The median filter, however, does not work well on noise that is close to the image's pixel values. <a href="image2.htm">Image 2</a> shows the boy image corrupted with the same type of impulse noise as in <a href="image1.htm">Image 1</a>. The result of the median filter is much better than that of the mean filter. The median filter threw out all the impulse noise pixels.</p>
<p>There are several types of noise commonly encountered in image processing. This paper looks at three types: 1) equal distribution noise, 2) Gaussian or normal distribution noise, and 3) salt and pepper noise (illustrated in <a href="image1.htm">Images 1</a> and <a href="image2.htm">2</a>). In equal distribution noise, all the pixels are spread evenly between two pixel values. <a href="fig1.htm">Equation (1)</a> shows this mathematically. It shows the probability of a pixel value in the image's histogram. In this equation, any pixel between gray levels a and b will occur the same number of times as any other pixel in that range. The image will not contain any pixels outside that range. Equal distribution noise occurs when using a digital camera with light concentrated in one visual band.</p>
<p>The histogram for Guassian noise is described by <a href="fig1.htm">Equation (2)</a>. This is the common normal distribution or bell curve. The gray levels of the pixels tend to cluster around a mean "m." The spread of gray levels about the mean is given by the standard deviation (s) "sigma." Gaussian noise is common in digital cameras and scanners. In scanners, the scanning light source is not perfect; it does not illuminate evenly. The illumination near the source is brighter than away from it. The pattern of brightness has a normal or Gaussian distribution.</p>
<p>Finally, salt and pepper noise contains two values: one bright (salt) and one dark (pepper). Specks of dust and dirt on a camera lens or a scanner bed are simple examples.</p>
<p><a href="image3.htm">Image 3</a> shows the boy image corrupted by the three types of noise. Though not as severe as the salt and pepper noise, the equal and Gaussian distribution noise corrupt the image.</p>
<p>The different types of noise also differ in the manner in which they combine with an image. The Gaussian and equal distribution noise are additive. Their values add to the pixel values in an image. Notice how the image corrupted with Gaussian and equal distribution noise (right side of <a href="image3.htm">Image 3</a>) is brighter than the original image. Adding the noise raises the pixel values. The salt and pepper noise is multiplicative. The values in salt and pepper (very bright and very dark) are multiplied by the values in the image. The very bright value saturates the input image, so its product is trimmed to the brightest value possible (white). The very dark value is a zero. Multiplying it by the original image produces a zero (black).</p>
<p>I wrote a utility program to generate the different types of  noise shown in the images. I don't discuss that program here, but you can download the source code for it, along with the source code for the filters described, and <B>.bat</B> files for generating the images shown, from the <I>CUJ</I> website at <B>www.cuj.com/code</B>.</p>
<p>For an explanation of the I/O routines; the median, high-pass, and low-pass filters; and the topic of spatial frequency filtering, see <a href="#3">[3]</a>.</p>
<p>The simple mean and median filters work well when you know a lot about the noise corrupting an image. They do not, however, work well when employed blindly. What we need are filters that adapt or change themselves based on the noise they encounter.</p>

<H4><FONT COLOR="#000080">Adaptive Filters</FONT></H4>

<p>Adaptive filters examine a noisy image and adapt their way of processing that image accordingly. This paper discusses three adaptive filters: 1) MMSE (Minimum Mean-Square Error), (2) DW-MTM (Double Window-Modified Trimmed Mean filter), and 3) SAM (Signal Adaptive Median) filter. These filters are described in <a href="#2">[2]</a> &#151; long, complicated names, but simple when you think about them.</p>
<p>Adaptive filters perform their job based on image statistics. <a href="fig1.htm">Equations (3), (4), and (5)</a> show the information these filters need to gather from the images. <a href="fig1.htm">Equation (3)</a> calculates the first moment (mean) of an image region; simply add up the pixel values and divide by the area. <a href="fig1.htm">Equation (4)</a> shows how to calculate the second moment of an image region. It is meaningful here only because we need it for <a href="fig1.htm">Equation (5)</a>. <a href="fig1.htm">Equation (5)</a> calculates the variance (s2) of the pixels in a region. The variance and its square root, the standard deviation, indicate the spread of pixel values in a region; these figures describe how much the values vary from the mean. A large variance usually indicates that an edge is within the region. Another explanation for a large variance is the presence of salt and pepper noise.</p>
<p><a href="list1.htm">Listing 1</a> shows the <B>moments</B> subroutine that calculates the first and second moments, the variance, and the standard deviation (s). The "else not out of bounds" section follows directly from <a href="fig1.htm">Equations (3), (4), and (5)</a>.</p>
<p>The <B>moments</B> subroutine calculates statistics from any size area in an image. This includes the statistics for an entire image. It can be used to find the noise variance in a background area of an image as well as the noise variance in an image that contains nothing but noise. I used <B>moments</B> in this last mode to find the noise variance for the examples shown.</p>
<p>The first adaptive filter to discuss is the MMSE filter. This filter produces an output equal to the input when the local variance is  much greater than the noise variance. (The noise variance is the variance of a plain background area containing nothing but noise.) When this happens, the input probably contains an edge, so leave it alone. If the local variance is about the same as the noise variance, the output becomes the mean of the local area. Therefore, the question for the MMSE filter is, do we apply a mean filter or do nothing?</p>
<p><a href="fig1.htm">Equation (6)</a> shows how the MMSE filter makes this decision. When the local and noise variances are about the same, the first term goes away, leaving only the local mean. When the local variance is much greater than the noise variance, the second term goes away, leaving only the input. Cases between the extremes produce mixtures of the two.</p>
<p><a href="list2.htm">Listing 2</a> shows the code that implements the MMSE filter. It allows the user to choose the size of the area being filtered (3x3, 5x5, etc.) with the <B>size</B> parameter. That parameter is sent to the <B>moments</B> subroutine to calculate the local variance and mean. The noise variance is known ahead of time and input by the user. The "else moments not out of bounds" section of code implements <a href="fig1.htm">Equation (6)</a>.</p>
<p><a href="image4.htm">Image 4</a> shows the result of the MMSE filter applied to an image corrupted by Gaussian noise. The result of the filter, far right, is not as clean as the input image (far left). Nevertheless, it is cleaner than the corrupted image (center).</p>
<p>The MMSE filter does not work well with impulse noise such as salt and pepper noise. <a href="image5.htm">Image 5</a> shows this failing. The "cleaned image" (far right) does not look much better than the corrupted one (center). The MMSE filter either passes the input to the output or outputs the mean of the input. <a href="image1.htm">Image 1</a> showed how poorly the mean works on such a noisy image.</p>
<p>The DW-MTM filter works much better on salt and pepper noise, and performs well on the Gaussian noise as well. The name, Double Window-Modified Trimmed Mean, comes from the DW-MTM filter's use of two windows, and its behavior of trimming away impulses when it calculates the mean of an area.</p>
<p>The DW-MTM filter algorithm starts with a pixel having coordinates x,y. First, the filter finds the median of a little region surrounding x,y (a 3x3, 5x5, etc.). Next, it uses a bigger region (the second or "double" window such as 5x5, 7x7, etc.) to find a mean. When finding the mean, the filter throws away or "trims off" any pixel if its gray level varies from the median by a certain factor. That factor is a constant K times the standard deviation of the noise. The constant K ranges from 1.5 to 2.5. This is because in a Gaussian distribution 95% of the values are within two standard deviations of the mean.</p>
<p>This process sounds more complicated than it is. <a href="list3.htm">Listing 3</a> shows the <B>dwmtm</B> subroutine. The user passes in the parameters that set the sizes of the two windows (<B>big_size</B> and <B>little_size</B>). Also passed in are the standard deviation of the noise and the constant K (<B>noise_sd</B> and <B>k</B>). The loops over <B>i</B> and <B>j</B> go through the entire image. The first section inside these loops finds the median in a little region. The next section finds the lower and upper range using this median and K times the standard deviation of the noise. Finally, the code calculates a mean using only the pixels with values inside the upper and lower range. This mean is put into the output image.</p>
<p><a href="image6.htm">Image 6</a> shows the result of applying the DW-MTM filter on the same noise used in <a href="image5.htm">Image 5</a> &#151; with drastic improvement. The result is not as crisp as the input, but it is much improved over the corrupted image. The DW-MTM filter also works well on Gaussian noise (left as an exercise for the reader).</p>
<p>The final adaptive filter described here (there are many more) is the signal adaptive median or SAM filter. The SAM filter uses the low-pass and high-pass filters described in <a href="#1">[1]</a> and <a href="#3">[3]</a>. Areas of an image containing high spatial frequencies typically contain edges. A high-pass filter passes these edges through. Areas of an image with low spatial frequencies are plain background; the low-pass filter passes these areas through and blurs edges. The strategy employed by the SAM filter is: if an area contains background or blurs, use a low-pass filter. Otherwise, use a high-pass filter.</p>
<p><a href="fig1.htm">Equation (7)</a> shows the SAM filter output. The factor K is adjusted by the presence or absence of edges. <a href="fig1.htm">Equation (8)</a> shows this adjustment &#151; the adaptive part of this filter. If the noise variance multiplied by a constant c is greater than the local variance, set K=0. The SAM filter becomes a low-pass filter. Otherwise, the SAM filter output also contains information passed by the high-pass filter. The values for c range from 0.0 on up. I had good results with c in the range 2.0 and 3.0.</p>
<p><a href="list4.htm">Listing 4</a> shows the SAM subroutine. First notice how this subroutine uses four image arrays instead of the usual two. The user passes in the types of low-pass and high-pass filters to use (see <a href="#1">[1]</a> and <a href="#3">[3]</a>). The outputs of these two filters go into the main loop over <B>i</B> and <B>j</B>. A call to the <B>moments</B> subroutine returns the local variance. The <B>konstant</B> (c) and the local and noise variance (passed in by the user) determine the factor K. This multiplies the high-pass filter result, and the product is summed with the low-pass filter result.</p>
<p><a href="image7.htm">Image 7</a> shows the result of the SAM filter applied to an image corrupted by Gaussian noise. The clean image, although not as crisp as the input image, is much better than the corrupted one.</p>

<H4><FONT COLOR="#000080">Putting It All Together</FONT></H4>

<p>The three adaptive filters become more useful when placed into a program. <a href="list5.htm">Listing 5</a> shows a main program that calls these filters. It uses a command-line interface that permits using batch of script files like the ones that created the images in this paper (also available in the online source archive accompanying this article).</p>

<H4><FONT COLOR="#000080">Conclusion</FONT></H4>

<p>This paper has introduced the topic of adaptive filters that remove noise from images. Images commonly contain many types of noise. Simple filters work well in simple cases. Adaptive filters perform much better because they adapt their algorithms to the type of image and type of noise present. There are many more types of adaptive filters available. You can create your own adaptive filter by using several available filters and switching among them based on information you find in the image.  The filters shown here have many parameters, and the examples given only scratched the surface. There are plenty of experiments to perform. As usual, have fun trying them.</p>

<H4><FONT COLOR="#000080">References</FONT></H4>

<p><a name="1"></a>[1]  Dwayne Phillips. "Image Processing Part 7: Spatial Frequency Filtering," <I>The C Users Journal,</I> October 1992.</p>
<p><a name="2"></a>[2]  Harley R. Myler and Arthur R. Weeks. <I>Computer Imaging Recipes in C</I> (Prentice Hall, 1993).</p>
<p><a name="3"></a>[3]  Dwayne Phillips. <I>Image Processing in C, Second Edition 2000</I>. Available at fatbrain.com on <B>http://www1.mightywords.com/asp/bookinfo/bookinfo.asp?theisbn=EB00014987</B>.</p>

<p><i><B>Dwayne Phillips</B> has worked as a software and systems engineer with the U.S. government since 1980. He has written </I>Image Processing in C, Second Edition 2000<I> (see fatbrain.com), and </I>The Software Project Manager's Handbook, Principles that Work at Work<I> (IEEE Computer Society, 1998). He has a Ph.D. in Electrical and Computer Engineering from Louisiana State University. He can be reached at <B>d.phillips@computer.org</B>.</i></p>

<h4><a href="../../../source/2000/dec00/phillips.zip">Get Article Source Code</a></h4>

</blockquote></body></html>
